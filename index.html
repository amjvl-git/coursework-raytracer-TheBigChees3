<!DOCTYPE html>
<html>

<body>

<canvas id="canvas" width="400" height="300" style="border:1px solid#000000;">
Your browser does not support the HTML canvas tag.
</canvas>

<script>


class Vec3 {
    constructor(x, y, z) {
        this.x = x;
        this.y = y;
        this.z = z;
    }
    add(other) {
        return new Vec3(this.x + other.x, this.y + other.y, this.z + other.z);
    }
    minus(other) {
        return new Vec3(this.x - other.x, this.y - other.y, this.z - other.z);
    }
    multiply(other) {
        return new Vec3(this.x * other.x, this.y * other.y, this.z * other.z);
    }
    scale(scalar) {
        return new Vec3(this.x * scalar, this.y * scalar, this.z * scalar);
    }
    dot(other) {
        return this.x * other.x + this.y * other.y + this.z * other.z;
    }
    magnitude() {
        return Math.sqrt(this.magnitudeSquared());
    }
    magnitudeSquared() {
        return this.x * this.x + this.y * this.y + this.z * this.z;
    }
    normalised() {
        let mag = this.magnitude();
        return this.scale(1 / mag);
    }
}

class Ray {
    constructor(origin, direction) {
        this.origin = origin;
        this.direction = direction.normalised();
    }
    pointAt(t) {
        return this.origin.add(this.direction.scale(t));
    }
}

class Sphere {
    constructor(centre, radius, colour) {
        this.centre = centre;
        this.radius = radius;
        this.colour = colour;
    }
    rayIntersects(ray) {
        let oc = ray.origin.minus(this.centre);
        let a = ray.direction.dot(ray.direction);
        let b = 2.0 * oc.dot(ray.direction);
        let c = oc.dot(oc) - this.radius * this.radius;
        let discriminant = b * b - 4 * a * c;
        if (discriminant < 0) return -1;
        return (-b - Math.sqrt(discriminant)) / (2.0 * a);
    }
}

function traceRay(ray) {
    let closestT = Infinity;
    let hitSphere = null;
    
    for (let i = 0; i < spheres.length; i++) {
        let t = spheres[i].rayIntersects(ray);
        if (t > 0 && t < closestT) {
            closestT = t;
            hitSphere = spheres[i];
        }
    }
    
    if (hitSphere) return hitSphere.colour;
    return new Vec3(0.3, 0.5, 0.9); // Background color
}

function setPixel(ctx, x, y, colour) {
    let r = Math.floor(colour.x * 255);
    let g = Math.floor(colour.y * 255);
    let b = Math.floor(colour.z * 255);
    ctx.fillStyle = `rgb(${r},${g},${b})`;
    ctx.fillRect(x, y, 1, 1);
}

const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");
const imageWidth = canvas.width;
const imageHeight = canvas.height;
const aspectRatio = imageHeight / imageWidth;

const spheres = [
    new Sphere(new Vec3(0, 0, -1), 0.3, new Vec3(1, 0, 0)),
    new Sphere(new Vec3(0, -100.5, -1), 100, new Vec3(0, 1, 0))
];

for (let i = 0; i < imageWidth; i++) {
    for (let j = 0; j < imageHeight; j++) {
        let u = (i / imageWidth) * 2 - 1;
        let v = (j / imageHeight) * 2 - 1;
        let ray = new Ray(new Vec3(0, 0, 0), new Vec3(u, v * aspectRatio, -1));
        let colour = traceRay(ray);
        setPixel(ctx, i, imageHeight - j - 1, colour);
    }
}
</script>

</body>
</html>